/**
 * Represents a way. A way is automatically added to the geohash index when
 * it is instantiated.
 * 
 * @augments Feature
 */
var Relation = Class.create(Feature, 
/**
 * @lends Node#
 */
{
	/**
	 * Ways (and nodes, but that hasn't been implemented) that make up this relation
	 */
	members: [],
	/**
	 * Sets up this relations's properties and adds it to the geohash index
	 * @param {Object} data     A set of properties that will be copied to this Way.
	 * @constructs
	 */
    initialize: function($super, data) {
		$super()
		
		this.id = Cartagen.relations.size()
		/**
		 * Number of frames this Way has existed for
		 * @type Number
		 */
		this.age = 0
		/**
		 * If true, this way will have a red border
		 * @type Boolean
		 */
		this.highlight = false
		/**
		 * If true, this way will be treated a a polygon and filled when drawn
		 * @type Boolean
		 */
		this.closed_poly = true // because all relations are currently coastlines

		this.outline_color = null
		this.outline_width = null
		
		Object.extend(this, data)
		
		this.collect_ways()
		
		if (this.nodes.length > 1 && this.nodes[0].x == this.nodes[this.nodes.length-1].x && 
			this.nodes[0].y == this.nodes[this.nodes.length-1].y) 
				this.closed_poly = true
		
		if (this.tags.get('natural') == "coastline") this.closed_poly = true
		
		if (this.closed_poly) {
			var centroid = Geometry.poly_centroid(this.nodes)
			this.x = centroid[0]*2
			this.y = centroid[1]*2
		} else {
			// attempt to make letters follow line segments:
			this.x = (this.middle_segment()[0].x+this.middle_segment()[1].x)/2
			this.y = (this.middle_segment()[0].y+this.middle_segment()[1].y)/2
		}
		
		this.area = Geometry.poly_area(this.nodes)
		// $l(this.nodes)
		this.bbox = Geometry.calculate_bounding_box(this.nodes)
		
		// calculate longest dimension to file in a correct geohash:
		this.width = Math.abs(Projection.x_to_lon(this.bbox[1])-Projection.x_to_lon(this.bbox[3]))
		this.height = Math.abs(Projection.y_to_lat(this.bbox[0])-Projection.y_to_lat(this.bbox[2]))
		
		Style.parse_styles(this,Style.styles.relation)
		// Geohash.put_object(this)
		Cartagen.relations.set('coastline_'+this.id,this)
    },
	/**
	 * Nodes of all member ways. Generated by Relation.collect_ways()
	 */
	nodes: [],
	/**
	 * Collected tags of all member ways. Generated by Relation.collect_ways()
	 */
	tags: new Hash(),
	/**
	 * Collects member ways into one long way.
	 */
	collect_ways: function() {
		$l('collecting ways')
		this.members.each(function(member) {
			this.nodes = this.nodes.concat(member.nodes)
			if (member.tags.size() > 0) this.tags.merge(member.tags)
		},this)
	},
	/**
	 * Draws this way on the canvas
	 */
	draw: function($super) {
		$super()
		this.age += 1;
	},
	/** 
	 * Finds the middle-most line segment
	 * @return a tuple of nodes
	 * @type Node[]
	 */	
	 middle_segment: Way.prototype.middle_segment,
	/**
	 * Finds the angle of the middle-most line segment
	 * @return The angle, in radians
	 * @type Number
	 */
	 middle_segment_angle: Way.prototype.middle_segment_angle,
	/**
	 * Applies hover and mouseDown styles
	 */
	style: Way.prototype.style,
	/**
	 * Draws on the canvas to display this relation
	 */
	shape: function() {

		if (this.highlight) {
			$C.line_width(3/Cartagen.zoom_level)
			$C.stroke_style("red")
		}
		// fade in after load:
		if (Object.isUndefined(this.opacity)) this.opacity = 1
		if (this.age < 20) {
			$C.opacity(this.opacity*(this.age/20))
		} else {
			$C.opacity(this.opacity)
		}

		$C.begin_path()
		
		if (Map.resolution == 0) Map.resolution = 1
		var is_inside = true, first_node = true, last_node
		this.nodes.each(function(node,index){
			if (is_inside || index == this.nodes.length-1) {
				if ((index % Map.resolution == 0) || index == 0 || index == this.nodes.length-1 || this.nodes.length <= 30) {
					if (first_node) {
						var corner = this.nearest_corner(this.nodes[0].x,this.nodes[0].y)
						Cartagen.node_count++
						$C.move_to(corner[0],corner[1])
						first_node = false
					}
					Cartagen.node_count++
					$C.line_to(node.x,node.y)
					is_inside = true
				}
			}
			last_node = node
			is_inside = (Math.abs(node.x - Map.x) < Viewport.width/2 && Math.abs(node.y - Map.y) < Viewport.height/2)
		},this)
		corner = this.nearest_corner(last_node.x,last_node.y)
		Cartagen.node_count++
		$C.line_to(corner[0],corner[1])
		// y1,x1,y2,x2
		// Viewport.bbox[]
		// if (corner[2] == 0) {
		// 	$C.line_to(corner[0],corner[1])
		// }

		// fill the polygon if the beginning and end nodes are the same.
		// we'll have to change this for open polys, like coastlines
		if (this.outlineColor && this.outlineWidth) $C.outline(this.outlineColor,this.outlineWidth)
		else $C.stroke()
		if (this.closed_poly) $C.fill()
	},
	/**
	 * Yields the x,y of the nearest Viewport corner in an array as [x,y,corner] where corner is 0,1,2,3 clockwise from top left
	 */
	nearest_corner: function(x,y) {
		var corner = []
		if (Viewport.bbox[1] - x > Viewport.bbox[3] - x) {
			corner[0] = Viewport.bbox[1]
			corner[2] = 0
		} else {
			corner[0] = Viewport.bbox[3]
			corner[2] = 1
		}
		if (Viewport.bbox[0] - y > Viewport.bbox[2] - y) {
			corner[1] = Viewport.bbox[0]
		} else {
			corner[1] = Viewport.bbox[2]
			corner[2] -= 1
			corner[2] *= -1 // swap 1 and 0
			corner[2] += 2
		}
		return corner
	}	
})